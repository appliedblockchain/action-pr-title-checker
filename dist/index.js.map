{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://javascript-action/../../../../../opt/homebrew/Cellar/ncc/0.34.0/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://javascript-action/webpack/bootstrap","../webpack://javascript-action/webpack/runtime/compat get default export","../webpack://javascript-action/webpack/runtime/define property getters","../webpack://javascript-action/webpack/runtime/hasOwnProperty shorthand","../webpack://javascript-action/webpack/runtime/make namespace object","../webpack://javascript-action/webpack/runtime/compat","../webpack://javascript-action/./index.js"],"sourcesContent":[null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","import * as core from \"@actions/core\";\nimport * as github from \"@actions/github\";\nconst [owner, repo] = process.env.GITHUB_REPOSITORY.split(\"/\");\nconst issue_number = github.context.issue.number;\nconst configPath = process.env.INPUT_CONFIGURATION_PATH;\nconst passOnOctokitError = process.env.INPUT_PASS_ON_OCTOKIT_ERROR === \"true\";\nconst { Octokit } = require(\"@octokit/action\");\n\nlet octokit;\n\n// most @actions toolkit packages have async methods\nasync function run() {\n  try {\n    const title = github.context.payload.pull_request.title;\n    const labels = github.context.payload.pull_request.labels;\n    const header = core.getInput(\"header\", { required: false }) || \"\";\n    const message = core.getInput(\"message\", { required: false });\n    let config;\n    try {\n      config = await getJSON(configPath);\n    } catch (e) {\n      core.setFailed(`Couldn't retrieve the config file specified - ${e}`);\n      return;\n    }\n    let { CHECKS, LABEL, MESSAGES } = JSON.parse(config);\n    LABEL.name = LABEL.name || \"title needs formatting\";\n    LABEL.color = LABEL.color || \"eee\";\n    CHECKS.ignoreLabels = CHECKS.ignoreLabels || [];\n    MESSAGES = MESSAGES || {};\n    MESSAGES.success = MESSAGES.success || \"All OK\";\n    MESSAGES.failure = MESSAGES.failure || \"Failing CI test\";\n    MESSAGES.notice = MESSAGES.notice || \"\";\n\n    for (let i = 0; i < labels.length; i++) {\n      for (let j = 0; j < CHECKS.ignoreLabels.length; j++) {\n        if (labels[i].name == CHECKS.ignoreLabels[j]) {\n          core.info(`Ignoring Title Check for label - ${labels[i].name}`);\n          removeLabel(labels, LABEL.name);\n          return;\n        }\n      }\n    }\n\n    try {\n      core.info(`Creating label (${LABEL.name})...`);\n      let createResponse = await octokit.issues.createLabel({\n        owner,\n        repo,\n        name: LABEL.name,\n        color: LABEL.color,\n      });\n      core.info(`Created label (${LABEL.name}) - ${createResponse.status}`);\n    } catch (error) {\n      // Might not always be due to label's existence\n      core.info(`Label (${LABEL.name}) already created.`);\n    }\n    if (CHECKS.prefixes && CHECKS.prefixes.length) {\n      for (let i = 0; i < CHECKS.prefixes.length; i++) {\n        if (title.startsWith(CHECKS.prefixes[i])) {\n          removeLabel(labels, LABEL.name);\n          core.info(MESSAGES.success);\n          return;\n        }\n      }\n    }\n\n    if (CHECKS.regexp) {\n      let re = new RegExp(CHECKS.regexp, CHECKS.regexpFlags || \"\");\n      if (re.test(title)) {\n        removeLabel(labels, LABEL.name);\n        core.info(MESSAGES.success);\n        return;\n      }\n    }\n\n    if(message.trim()){\n      await createComment(octokit, repo, issue_number, message, header);\n    }\n\n    await titleCheckFailed(CHECKS, LABEL, MESSAGES);\n  } catch (error) {\n    core.info(error);\n  }\n}\n\nasync function titleCheckFailed(CHECKS, LABEL, MESSAGES) {\n  try {\n    if (MESSAGES.notice.length) {\n      core.notice(MESSAGES.notice);\n    }\n\n    await addLabel(LABEL.name);\n\n    if (CHECKS.alwaysPassCI) {\n      core.info(MESSAGES.failure);\n    } else {\n      core.setFailed(MESSAGES.failure);\n    }\n  } catch (error) {\n    core.info(error);\n    if (CHECKS.alwaysPassCI) {\n      core.info(`Failed to add label (${LABEL.name}) to PR`);\n    } else {\n      core.setFailed(`Failed to add label (${LABEL.name}) to PR`);\n    }\n  }\n}\n\nasync function addLabel(name) {\n  core.info(`Adding label (${name}) to PR...`);\n  let addLabelResponse = await octokit.issues.addLabels({\n    owner,\n    repo,\n    issue_number,\n    labels: [name],\n  });\n  core.info(`Added label (${name}) to PR - ${addLabelResponse.status}`);\n}\n\nasync function removeLabel(labels, name) {\n  try {\n    if (\n      !labels\n        .map((label) => label.name.toLowerCase())\n        .includes(name.toLowerCase())\n    ) {\n      return;\n    }\n\n    core.info(\"No formatting necessary. Removing label...\");\n    let removeLabelResponse = await octokit.issues.removeLabel({\n      owner,\n      repo,\n      issue_number,\n      name: name,\n    });\n    core.info(`Removed label - ${removeLabelResponse.status}`);\n  } catch (error) {\n    core.info(`Failed to remove label (${name}) from PR: ${error}`);\n  }\n}\n\nasync function getJSON(repoPath) {\n  const response = await octokit.repos.getContent({\n    owner,\n    repo,\n    path: repoPath,\n    ref: github.context.sha,\n  });\n\n  return Buffer.from(response.data.content, response.data.encoding).toString();\n}\n\nasync function handleOctokitError(e) {\n  core.info(`Octokit Error - ${e}`);\n  if (passOnOctokitError) {\n    core.info(\"Passing CI regardless\");\n  } else {\n    core.setFailed(\"Failing CI test\");\n  }\n}\n\nasync function createComment(octokit, repo, issue_number, body, header) {\n  await octokit.issues.createComment({\n    ...repo,\n    issue_number,\n    body: `${body}\\n${headerComment(header)}`\n  });\n}\n\n\ntry {\n  octokit = new Octokit();\n} catch (e) {\n  handleOctokitError(e);\n}\n\nif (octokit) {\n  run();\n}\n"],"names":[],"sourceRoot":""}